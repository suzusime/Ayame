字句解析仕様
===========

この文書は文目言語の字句解析に関する詳細な仕様です。

普通にスクリプトを書くだけの人が読む必要はないでしょう。

## トークン
読み込まれたスクリプトは以下の7種類のトークンに分割される。

- 区切り
- リテラル
- 変数
- 改行
- 開き角括弧
- 閉じ角括弧
- タブ
- シャープ

注意：この他に内部では「スラッシュ」「ドル記号」の2種類のトークンを字句解析時には用いているが、字句解析器からの出力の際には削除されるため、ふだん気にする機会はないはずである。

### 区切り
半角空白。

連続する半角空白はひとつの区切りトークンにまとめられる。

注意：タブや改行は基本的に別の種類のトークンとなるため、区切りとはならない。しかし、特殊な状況下（函数の括弧の中）ではタブや改行は半角空白として扱われ、区切りとなる。詳細は後述。

### リテラル
普通の文字列。

「他の種類のトークンに区切られたひとつなぎの文字の列」が1つのリテラルにまとめられる。

#### 例1
```
こんにちは
```
この場合は「`こんにちは`」でひとつのリテラルとなる。

#### 例2
```
魔法少女 まじかる☆ななせ
```
この場合、「魔法少女」と「まじかる☆ななせ」の間に区切りのトークンが存在するため、「魔法少女」と「まじかる☆ななせ」がそれぞれリテラルとなる。

以下、このように分割されることを

```
"魔法少女" <d> "まじかる☆ななせ"
```
のように記述することにする（以下このような表記法を「トークン表記」と称することにする）。

リテラルは内容を二重引用符で囲って表し、区切りは`<d>`と表すのである（dはdelimiter（区切り）の頭文字である）。

また、トークンの間にはスペースを入れて表記するが、これは単に見やすさのためであり、実際にそこにスペースがあるわけではない（実際にあるスペースはすべて`<d>`と書かれることになる）。

### 変数
- `$`記号の後に以下で示す「変数名に使用可能な文字」を続けると、それは変数と解釈される。

#### 例1
```
$hero
```
これは`hero`という名前の変数を呼び出すためのトークンとなる。

これを、次のように表記することと約束する（トークンとしての表記も見た目と同じになる）。

```
$hero 
```

#### 変数名に使用可能な文字
- 半角英数字(`0-9`, `A-Z`, `a-z`)
- アットマーク(`@`)
- アンダーバー(`_`)

注意：文法的にはこれらの文字の自由な順序の組み合わせを許容する。しかし、先頭が`@`となる変数は実行時に特殊な扱いをする等の、（実行時に於ける）規則が存在する。この文書ではこれらの規則について触れないので、実行機械の仕様書を参照してほしい。

#### 例2
```
俺の名は$@hero_no_namaeだ。
```
は、トークン表記では
```
"俺の名は" $@hero_no_namae "だ。"  
```
となる。

「だ」は変数名に使用可能な文字ではないので、その前までが変数名であると解釈される。

#### 例3
```
ここからあの島まで$kyori kmあるが、泳ぐなんて正気か？
```
は、トークン表記では
```
"ここからあの島まで" $kyori <d> "kmあるが、泳ぐなんて正気か？"
```
となる。

「k」は変数名に使用可能な文字であるから、そのまま変数名のあとに続けると変数名の一部であると解釈されてしまう。このような場合、区切り文字を入れるなどして変数名の一部ではないことを明示する必要がある。

### 改行
改行。

トークン表記では普通に改行として表すか、または `<LF>` とかく。

### 開き角括弧
`[` である。

トークン表記ではそのまま `[` と書く。

### 閉じ角括弧
`]` である。

トークン表記ではそのまま `]` と書く。

### タブ文字
タブ文字（HF, U+09）。

この言語ではタブ文字が重要な文法要素となる。

トークン表記では `<t>` と書く。

### シャープ
`#`（正確には「井桁」）。

トークン表記では、そのまま `#` と書く。

## 文字コードについて
文目言語は入力文字コードの符号化文字集合がUnicodeであることを仮定する。

よって文字単位の扱いを行う必要がある場合はUnicodeとしての1文字が基準となる。
結合文字などは1文字として扱う。
正確な扱いはC#の `StringInfo.GetTextElementEnumerator()` メソッドに依存しているので、詳細はそのドキュメントを参照せよ。

符号化形式は実装依存である。

## 改行コードについて
改行コードはLFである。

字句解析の前にプリプロセスとして改行コードをLFに統一する処理を行う。

## コメントについて
スクリプト中に `//` が現れた場合、これ以降その行を __改行文字を含めて__ 無視する。

#### 例
```
$hero//これは主人公の名前
	噓だっ！正気のお前なら、あんなこと言うはずない！
```
は、トークン表記では
```
$hero <t> "噓だっ！正気のお前なら、あんなこと言うはずない！"
```
となる。

即ち、
```
$hero	噓だっ！正気のお前なら、あんなこと言うはずない！
```
と書いた場合と全く同じ結果が得られる。

## 函数中での区切りの特殊な扱いについて
文目言語において函数は `[func arg1 arg2]` のような形式で表現される（詳細は構文解析仕様を参照）。

函数の引数は区切り文字で表されるが、この際に便利なように「函数の[]で囲われた中では（半角空白のほかに）改行、タブ文字も区切りとみなす」という特殊な処理を行う。

#### 例1
```
[func
   arg1 //ここには条件を入れる
   arg2]//条件が真のときこれが表示される
```
は、トークン表記では
```
[ "func" <d> "arg1" <d> "arg2"]
```
となる。

#### 例2
入れ子の場合も同様である。
```
[func1
    arg1
    [func2
        arg2
        arg3]]
```
は、トークン表記では
```
[ "func1" <d> "arg1" <d> [ "func2" <d> "arg2" <d> "arg3" ] ]
```
となる。

## エスケープについて
スクリプト中に `\` が現れた場合、この次の文字を無条件でリテラルを構成する1文字として扱う。

例えば、`a pen` はトークン表記で `"a" <d> "pen"` となるが、`a\ pen` はトークン表記で `"a pen"`となる。

